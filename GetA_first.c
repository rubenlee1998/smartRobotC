#pragma config(Sensor, S1,     c1,             sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S2,     c2,             sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     c3,             sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorB,          lm,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          rm,            tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define Black 1
#define Blue 2
#define Green 3
#define Yellow 4
#define Red 5
#define White 6
#define Brown 7
int nMotorSpeedSetting = 20, vertex = 0, count = 0, row = 0, val, positionRow = 0, positionColumn = 0, score = 0;
int columnNumber = 3, rowNumber = 3, back_count=0 ,directionUp=0, directionLeft=1;
int a = 0, b = 0;
int dt[4][4], M[4][4];

void setSpeedAndSleep(int leftSpeed, int rightSpeed, int time)
{
    setMotorSpeed(lm, leftSpeed);
    setMotorSpeed(rm, rightSpeed);
    sleep(time);
}

void stopMotor()
{
    setMotorSpeed(lm, 0);
    setMotorSpeed(rm, 0);
}

void getScore(){
    int i=0, certainColor=0, tmpColor=0;
    setSpeedAndSleep(-10, -10, 500);
    stopMotor();
    while(i<200){
        tmpColor = getColorName(c2);
        if(tmpColor == Green || tmpColor == Red){
            certainColor = tmpColor;
        }
        i++;
        setSpeedAndSleep(15, -15, 2);
    }
    setSpeedAndSleep(-15, 15, 400);
    stopMotor();
    if(certainColor == Red){
        displayBigTextLine(1, "RED: score +1");
        sleep(500);
        playTone(240, 20);
        sleep(300);
        score+=1;
    }
    else if(certainColor == Green){
        displayBigTextLine(1, "GREEN: score -1");
        sleep(500);
        playTone(240, 20);
        sleep(300);
        score-=1;
    }
    else{
        displayBigTextLine(1, "NULL: 0");
        sleep(500);
    }
    setSpeedAndSleep(15, 15, 400);
}

void patchSector(){
    int i=0, certainColor=0, tmpColor=0;
    setSpeedAndSleep(15, -15, 150);
    stopMotor();
    while(i<200){
        tmpColor = getColorName(c2);
        if(tmpColor == Green || tmpColor == Red) certainColor = tmpColor;
        i++;
        setSpeedAndSleep(15, -15, 1);
    }
    setSpeedAndSleep(-15, 15, 300);
    stopMotor();
    if(row % 2 == 0) { //even
       if(certainColor == Green){
           displayBigTextLine(1,"Map[%d][%d] = Green",row ,++count);
           M[row][count] = -1;
           sleep(500);
       }
       else if(certainColor == Red){
           displayBigTextLine(1,"Map[%d][%d] = RED",row ,++count);
           M[row][count] = 1;
           sleep(500);
       }
       else {
           displayBigTextLine(1,"Map[%d][%d] = NOT",row ,++count);
           M[row][count] = 0;
           sleep(500);
       }
    }
    else if(row % 2 != 0) { //odd
        if(certainColor == Green){
           displayBigTextLine(1,"Map[%d][%d] = Green",row ,columnNumber-(++count));
           M[row][columnNumber-count] = -1;
           sleep(500);
        }
        else if(certainColor == Red){
           displayBigTextLine(1,"Map[%d][%d] = RED",row ,columnNumber-(++count));
           M[row][columnNumber-count] = 1;
           sleep(500);
        }
        else {
           displayBigTextLine(1,"Map[%d][%d] = NOT",row ,columnNumber-(++count));
           M[row][columnNumber-count] = 0;
           sleep(500);
        }
    }
}

void getColorIncreaseVertex(short colorSensor)
{
    if (getColorName(colorSensor) == Yellow && count != columnNumber) vertex++;
    else vertex = 0;
}

void go(){
    val = 5;
    //Line tracing
    if (getColorName(c2) == Yellow) setSpeedAndSleep(nMotorSpeedSetting - val, nMotorSpeedSetting + val, 1);
    else setSpeedAndSleep(nMotorSpeedSetting + val, nMotorSpeedSetting - val, 1);
    if (row == 0) getColorIncreaseVertex(c3);
    else if (row % 2 == 0) getColorIncreaseVertex(c1);
    else getColorIncreaseVertex(c3);
    if (vertex == 1) patchSector();
}

void turnLeft()
{
    setSpeedAndSleep(24, 25, 400);
    while (getColorName(c1) > Yellow) setSpeedAndSleep(-nMotorSpeedSetting * 6 / 10, nMotorSpeedSetting * 6 / 10, 10);
    setSpeedAndSleep(-nMotorSpeedSetting * 6 / 10, nMotorSpeedSetting * 6 / 10, 400);
    while (getColorName(c2) > Yellow) setSpeedAndSleep(-nMotorSpeedSetting * 4 / 10, nMotorSpeedSetting * 4 / 10, 10);
    sleep(80);
    setSpeedAndSleep(0, 0, 200);
}

void turnRight()
{
    setSpeedAndSleep(25, 25, 350);
    while (getColorName(c3) > Yellow) setSpeedAndSleep(nMotorSpeedSetting * 6 / 10, -nMotorSpeedSetting * 6 / 10, 10);
    while (getColorName(c2) > Yellow) setSpeedAndSleep(nMotorSpeedSetting * 6 / 10, -nMotorSpeedSetting * 6 / 10, 1);
    sleep(80);
    setMotorSpeed(lm, 0);
    sleep(200);
    setMotorSpeed(rm, 0);
}

void getColorIncreaseCount(short colorSensor)
{
    if (getColorName(colorSensor) == Yellow) count++;
    else count=0;
}

void resetRobotDirection()
{
    directionLeft = 0;
    directionUp = 0;
}

void goUp()
{
    row++;
    if (positionRow == 0 && a == 0)
    {
        a = 1;
        resetRobotDirection();
        turnLeft();
        directionLeft = 1;
    }
    else if (positionColumn == 0 && b == 0)
    {
        b = 1;
        resetRobotDirection();
        turnRight();
        directionUp = 1;
    }
    else
    {
        if (directionLeft == 1)
        {
            resetRobotDirection();
            turnRight();
            directionUp = 1;
        }
    }
    count = 0;
    positionRow--;
    while (true)
    {
        if (getColorName(c2) == Yellow) setSpeedAndSleep(nMotorSpeedSetting - val, nMotorSpeedSetting + val, 1);
        else setSpeedAndSleep(nMotorSpeedSetting + val, nMotorSpeedSetting - val, 1);
        if (positionColumn == columnNumber) getColorIncreaseCount(c1);
        else if (positionRow == rowNumber) getColorIncreaseCount(c3);
        else if (positionColumn == 0) getColorIncreaseCount(c1);
        else if (positionRow == 0) getColorIncreaseCount(c3);
        else getColorIncreaseCount(c3);
        if (count == 1)
        {
            setSpeedAndSleep(15, 15, 420);
            getScore();
            break;
        }
	}
}

void goLeft()
{   // count =0;
    if (positionRow == 0 && a == 0)
    {
        a = 1;
        resetRobotDirection();
        turnLeft();
        directionLeft = 1;
    }
    else if (positionColumn == 0 && b == 0)
    {
        b = 1;
        resetRobotDirection();
        turnRight();
        directionUp = 1;
    }
    else
    {
        if (directionUp == 1)
        {
            resetRobotDirection();
            turnLeft();
            directionLeft = 1;
        }
    }
    count = 0;
    positionColumn--;
    while (true)
    {
        if (getColorName(c2) == Yellow) setSpeedAndSleep(nMotorSpeedSetting - val, nMotorSpeedSetting + val, 1);
        else setSpeedAndSleep(nMotorSpeedSetting + val, nMotorSpeedSetting - val, 1);
        if (positionColumn == columnNumber) getColorIncreaseCount(c1);
        else if (positionRow == rowNumber) getColorIncreaseCount(c3);
        else if (positionColumn == 0) getColorIncreaseCount(c1);
        else if (positionRow == 0) getColorIncreaseCount(c3);
        else getColorIncreaseCount(c3);
        if (count == 1)
        {
            setSpeedAndSleep(15, 15, 420);
            getScore();
            break;
        }
    }
}

void completeSearch(){
    sleep(1000);
    while (true){
        if (count != columnNumber) go();
        if (count == columnNumber)
        { // if robot is end of column
            if (row == rowNumber) return; // all grid scanning complete
            if (row % 2 == 0)
            { // move backward
                setSpeedAndSleep(35, 30, 200);
                turnRight();
            }
            else
            { // if robot is middle of line
                setSpeedAndSleep(30, 35, 200);
                turnLeft();
            }
            row++;
            if (row % 2 == 0)
            {
                while (getColorName(c1) == White) go();
                count = -1;
                patchSector();
                setSpeedAndSleep(30, 35, 200);
                turnLeft();
            }
            else
            {
                while (getColorName(c3) == White) go();// move next column(black col line)
                count = -1;
                patchSector();
                setSpeedAndSleep(35, 30, 200);
                turnRight(); // turn agian
            }
            count = 0; // reset scaning, position
            sleep(400);
        }
    }
}

void printMap()
{
    char map[4][4];
    for (int i = 0; i <= rowNumber; i++)
    {
        for (int j = 0; j <= columnNumber; j++)
        {
            if (M[i][j] == 0) map[i][j] = '+';
            else if (M[i][j] == 1) map[i][j] = 'O';
            else if (M[i][j] == -1) map[i][j] = 'X';
        }
    }
    for(int i = 0; i <=rowNumber; i++)
       for(int j = 0; j <= columnNumber; j++)
          displayStringAt( (j+1)*10, 100-(i+1)*10, "%c", map[i][j] );
    sleep(5000);
}

void backMovingPoint()
{
    while(true){
        if (getColorName(c2) == Yellow) setSpeedAndSleep(nMotorSpeedSetting - val, nMotorSpeedSetting + val, 1);
        else setSpeedAndSleep(nMotorSpeedSetting + val, nMotorSpeedSetting - val, 1);
        if (getColorName(c1) == Yellow){
            back_count++;
            setSpeedAndSleep(15, 15, 420);
            setSpeedAndSleep(0, 0, 420);
        }
        if(back_count == columnNumber) return;
    }
}

void cal(){
    for(int i=0; i<=rowNumber; i++){
        for(int j=0; j<=columnNumber; j++){
            if(i==0 && j==0) dt[i][j] = M[i][j];
            else if(i == 0) dt[i][j] = dt[i][j-1] + M[i][j];
            else if(j==0) dt[i][j] = dt[i-1][j] + M[i][j];
            else {
                if(dt[i-1][j] > dt[i][j-1]) dt[i][j] = dt[i-1][j] + M[i][j];
                else dt[i][j] = dt[i][j-1] + M[i][j];
            }
        }
    }
}

task main()
{
    while (getButtonPress(1) == 0) sleep(10);
    completeSearch();
    setSpeedAndSleep(15, -15, 2250);
    setSpeedAndSleep(-15, -15, 1500);
    backMovingPoint();
    setSpeedAndSleep(15, -15, 2250);
    setSpeedAndSleep(-15, -15, 1300);
    stopMotor();
    printMap();
    sleep(4000);
    cal();
    positionColumn = columnNumber; positionRow = rowNumber; row = 0;
    // go back
    while (positionRow != 0 || positionColumn != 0){
        if(positionRow==0) goLeft();
        else if(positionColumn==0) goUp();
        else if(dt[positionRow-1][positionColumn] > dt[positionRow][positionColumn-1]) goUp();
        else goLeft();
        eraseDisplay();
    }
    playTone(240, 20);
    sleep(300);
    stopMotor();
    while (getButtonPress(1) == 0) sleep(10);
    displayBigTextLine(1, "final score = %d", score);
    sleep(5000);
}
